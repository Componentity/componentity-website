"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const path_1 = require("path");
const child_process_1 = require("child_process");
const util_1 = require("util");
const fs_extra_1 = require("fs-extra");
const tar_1 = require("tar");
const node_fetch_1 = __importDefault(require("node-fetch"));
const ramda_1 = require("ramda");
const utils_1 = require("../utils");
const allowedExistingContent = ["readme.md", "license", ".git", ".gitignore"];
const faviconUrl = "https://favicon.frontity.org/";
/**
 * This function normalizes and validates options.
 *
 * @param defaultOptions - The default options. Defined in {@link
 * CreateCommandOptions}.
 * @param passedOptions - The options from the user. Defined in {@link
 * CreateCommandOptions}.
 *
 * @returns The final options, normalized. Defined in {@link
 * CreateCommandOptions}.
 */
exports.normalizeOptions = (defaultOptions, passedOptions) => {
    const options = ramda_1.mergeRight(defaultOptions, passedOptions);
    // Normalize and validate `name` option.
    options.name = options.name.replace(/[\s_-]+/g, "-").toLowerCase();
    if (!utils_1.isPackageNameValid(options.name))
        throw new Error("The name of the package is not valid. Please enter a valid one (only letters and dashes).");
    return options;
};
/**
 * This function ensures the path exists and checks if it's empty or it's a new
 * repo. Also returns a boolean indicating if the directory existed already.
 *
 * @param path - The path where the project will be installed.
 *
 * @returns A promise that resolves once the check has been made.
 */
exports.ensureProjectDir = async (path) => {
    const dirExisted = await fs_extra_1.pathExists(path);
    if (dirExisted) {
        // Check if the directory is a new repo.
        const dirContent = await fs_extra_1.readdir(path);
        const notAllowedContent = dirContent.filter((content) => !allowedExistingContent.includes(content.toLowerCase()));
        // If it's not, throw.
        if (notAllowedContent.length) {
            throw new Error("The directory passed to `create` function is not empty");
        }
    }
    else {
        await fs_extra_1.ensureDir(path);
    }
    return dirExisted;
};
/**
 * Create a `package.json` file.
 *
 * @param name - The name of the project.
 * @param theme - The theme that will be cloned and installed locally.
 * @param path - The path where the file will be created.
 */
exports.createPackageJson = async (name, theme, path) => {
    const packages = [
        "frontity",
        "@frontity/core",
        "@frontity/wp-source",
        "@frontity/tiny-router",
        "@frontity/html2react",
    ];
    // Add Frontity packages to the dependencies.
    const dependencies = (await Promise.all(packages.map(async (pkg) => {
        // Get the version of each package.
        const version = await utils_1.fetchPackageVersion(pkg);
        return [pkg, `^${version}`];
    }))).reduce((final, current) => {
        // Reduce the packages into a dependecies object.
        final[current[0]] = current[1];
        return final;
    }, {});
    // Add the starter theme to the dependencies.
    const themeName = (theme.match(/\/?([\w-]+)$/) || ["", ""])[1];
    dependencies[theme] = `./packages/${themeName}`;
    const packageJson = {
        name,
        version: "1.0.0",
        private: true,
        description: "Frontity project",
        keywords: ["frontity"],
        engines: {
            node: ">=10.0.0",
            npm: ">=6.0.0",
        },
        scripts: {
            dev: "frontity dev",
            build: "frontity build",
            serve: "frontity serve",
        },
        prettier: {},
        dependencies,
    };
    const filePath = path_1.resolve(path, "package.json");
    const fileData = `${JSON.stringify(packageJson, null, 2)}${os_1.EOL}`;
    await fs_extra_1.writeFile(filePath, fileData);
};
/**
 * Create a `README.md` file.
 *
 * @param name - The name of the project.
 * @param path - The path where the file will be created.
 */
exports.createReadme = async (name, path) => {
    const fileTemplate = await fs_extra_1.readFile(path_1.resolve(__dirname, "../../templates/README.md"), {
        encoding: "utf8",
    });
    const filePath = path_1.resolve(path, "README.md");
    const fileData = fileTemplate.replace(/\$name\$/g, name);
    await fs_extra_1.writeFile(filePath, fileData);
};
/**
 * Create a `frontity.settings` file.
 *
 * @param extension - The extension of the file, either `.js` or `.ts`.
 * @param name - The name of the project.
 * @param path - The path where the file will be created.
 * @param theme - The theme installed in the project.
 */
exports.createFrontitySettings = async (extension, name, path, theme) => {
    const frontitySettings = {
        name,
        state: {
            frontity: {
                url: "https://test.frontity.org",
                title: "Test Frontity Blog",
                description: "WordPress installation for Frontity development",
            },
        },
        packages: [
            {
                name: theme,
                state: {
                    theme: {
                        menu: [
                            ["Home", "/"],
                            ["Nature", "/category/nature/"],
                            ["Travel", "/category/travel/"],
                            ["Japan", "/tag/japan/"],
                            ["About Us", "/about-us/"],
                        ],
                        featured: {
                            showOnList: false,
                            showOnPost: false,
                        },
                    },
                },
            },
            {
                name: "@frontity/wp-source",
                state: {
                    source: {
                        api: "https://test.frontity.org/wp-json",
                    },
                },
            },
            "@frontity/tiny-router",
            "@frontity/html2react",
        ],
    };
    const fileTemplate = await fs_extra_1.readFile(path_1.resolve(__dirname, `../../templates/settings-${extension}-template`), { encoding: "utf8" });
    const filePath = path_1.resolve(path, `frontity.settings.${extension}`);
    const fileData = fileTemplate.replace(/\$([\w-]+)\$/g, (_match, key) => {
        if (key === "settings")
            return JSON.stringify(frontitySettings, null, 2);
    });
    await fs_extra_1.writeFile(filePath, fileData);
};
/**
 * Clone the starter theme.
 *
 * @param theme - The name of the theme.
 * @param path - The path where it needs to be installed.
 */
exports.cloneStarterTheme = async (theme, path) => {
    const packageJsonPath = path_1.resolve(path, "./package.json");
    const packageJson = JSON.parse(await fs_extra_1.readFile(packageJsonPath, { encoding: "utf8" }));
    const themePath = path_1.resolve(path, packageJson.dependencies[theme]);
    await fs_extra_1.ensureDir(themePath);
    if (!utils_1.isThemeNameValid(theme))
        throw new Error("The name of the theme is not a valid npm package name.");
    await util_1.promisify(child_process_1.exec)(`npm pack ${theme}`, { cwd: themePath });
    const tarball = (await fs_extra_1.readdir(themePath)).find((file) => /\.tgz$/.test(file));
    const tarballPath = path_1.resolve(themePath, tarball);
    await tar_1.extract({ cwd: themePath, file: tarballPath, strip: 1 });
    await fs_extra_1.remove(tarballPath);
};
/**
 * Install the Frontity packages.
 *
 * @param path - The location where `npm install` should be run.
 */
exports.installDependencies = async (path) => {
    await util_1.promisify(child_process_1.exec)("npm install", { cwd: path });
};
/**
 * Downlaod the favicon file.
 *
 * @param path - The path where the favicon should be downloaded.
 */
exports.downloadFavicon = async (path) => {
    const response = await node_fetch_1.default(faviconUrl);
    const fileStream = fs_extra_1.createWriteStream(path_1.resolve(path, "favicon.ico"));
    response.body.pipe(fileStream);
    await new Promise((resolve) => fileStream.on("finish", resolve));
};
/**
 * Remove the files and directories created with `frontity create` in case there
 * was a problem and we need to revert everything.
 *
 * @param dirExisted - If the directory existed already.
 * @param path - The path of the direcotry.
 */
exports.revertProgress = async (dirExisted, path) => {
    if (dirExisted) {
        const content = await fs_extra_1.readdir(path);
        const removableContent = content
            .filter((item) => !allowedExistingContent.includes(item.toLowerCase()))
            .map((item) => path_1.resolve(path, item));
        for (const content of removableContent)
            await fs_extra_1.remove(content);
    }
    else {
        await fs_extra_1.remove(path);
    }
};
/**
 * Check if an email is valid or not.
 *
 * @param email - The email to be checked.
 *
 * @returns True or false depending if the email is valid.
 */
const isEmailValid = (email) => /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,63}$/i.test(email);
/**
 * Subscribe an email to the newsletter service.
 *
 * @param email - The email to be subscribed.
 *
 * @returns The response of the subscription.
 */
exports.subscribe = async (email) => {
    if (!isEmailValid(email))
        throw new Error("Email not valid. Please enter a valid email.");
    return node_fetch_1.default("https://hook.integromat.com/gm0b502jo5acuhzko7gszx0kd9r52ofi", {
        method: "POST",
        body: JSON.stringify({
            event: "frontity-subscribe",
            email: email.toLowerCase(),
        }),
        headers: { "Content-Type": "application/json" },
    });
};
