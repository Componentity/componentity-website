"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ora_1 = __importDefault(require("ora"));
const chalk_1 = __importDefault(require("chalk"));
const path_1 = require("path");
const inquirer_1 = require("inquirer");
const create_package_1 = __importDefault(require("../commands/create-package"));
const utils_1 = require("../utils");
/**
 * The create CLI command, usually run with `npx frontity create-package`.
 *
 * It takes args from the CLI and checks for the presence of environment
 * variables. Then, it runs the create command programatically.
 *
 * @param options - Defined in {@link CreatePackageOptions}.
 */
const createPackage = async ({ name, namespace, prompt: promptUser, }) => {
    name = name || process.env.FRONTITY_CREATE_PACKAGE_NAME;
    namespace = namespace || process.env.FRONTITY_CREATE_PACKAGE_NAMESPACE;
    if (!promptUser && !name) {
        utils_1.errorLogger(new Error("You need to provide the name for the package."));
    }
    // Init options.
    const options = {};
    // Validate project location.
    options.projectPath = process.cwd();
    if (!(await utils_1.isFrontityProjectRoot(options.projectPath))) {
        utils_1.errorLogger(new Error("You must execute this command in the root folder of a Frontity project."));
    }
    if (name) {
        // Name was passed as arg or env variable.
        options.name = name;
    }
    else if (promptUser) {
        // Name was missing, but we can prompt.
        const questions = [
            {
                name: "name",
                type: "input",
                message: "Enter the name of the package:",
                default: "my-frontity-package",
            },
        ];
        const answers = await inquirer_1.prompt(questions);
        options.name = answers.name;
    }
    else {
        // Name is missing and we can't prompt. Stop.
        utils_1.errorLogger(new Error("You need to provide the name of the package."));
    }
    if (namespace) {
        // Namespace was passed as arg or env variable.
        options.namespace = namespace;
    }
    else if (promptUser) {
        // Namespace was missing, but we can prompt.
        const questions = [
            {
                name: "namespace",
                type: "input",
                message: "Enter the namespace of the package:",
                default: "theme",
            },
        ];
        const answers = await inquirer_1.prompt(questions);
        options.namespace = answers.namespace;
    }
    else {
        // Add the default option.
        options.namespace = "theme";
    }
    if (!utils_1.isThemeNameValid(options.name)) {
        utils_1.errorLogger(new Error("The name of the package is not a valid npm package name. Please start again."));
    }
    // Set the package path.
    options.packagePath = path_1.normalize(`packages/${options.name.replace(/(?:@.+\/)/i, "")}`);
    try {
        // Get the emitter for `create-package`.
        const emitter = create_package_1.default(options);
        emitter.on("message", (message, action) => {
            if (action)
                ora_1.default.promise(action, message);
            else
                utils_1.log(message);
        });
        // Actually create the package.
        await emitter;
    }
    catch (error) {
        utils_1.errorLogger(error);
    }
    utils_1.log(chalk_1.default.bold(`\nNew package "${options.name}" created.\n`));
};
exports.default = createPackage;
